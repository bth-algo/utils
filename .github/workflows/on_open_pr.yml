name: Check requirements for opening PR

on:
  workflow_call:
    inputs:
      course_id:
        required: true
        type: string
      available_assignments:
        required: true
        type: string
      student_id:
        required: true
        type: string
      kmom_paths:
        required: true
        type: string

jobs:
  validate-tag:
    runs-on: ubuntu-latest
    outputs:
      workflow_passed: ${{ steps.check.outputs.workflow_passed }}
      error_message: ${{ steps.check.outputs.error_message }}
    steps:
      - name: Check latest tag workflow status
        id: check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.READ_ORG_TOKEN }}
          script: |
            const baseRef = '${{ github.base_ref }}';
            console.log(`Base ref: ${baseRef}`);
            
            // Extract kmom from branch (e.g., bth/submit/kmom03 -> kmom03)
            const kmomMatch = baseRef.match(/bth\/submit\/(kmom\d+)/);
            if (!kmomMatch) {
              core.setOutput('workflow_passed', 'false');
              core.setOutput('error_message', `Invalid branch format: ${baseRef}. Expected bth/submit/kmomXX`);
              return;
            }
            
            const kmom = kmomMatch[1];
            console.log(`Extracted kmom: ${kmom}`);
            
            // Extract kmom number (e.g., kmom03 -> 03, kmom10 -> 10)
            const kmomNum = kmom.replace('kmom', '');
            const tagPrefix = `v${kmomNum}`;
            console.log(`Looking for tags starting with: ${tagPrefix}`);
            
            // Get all tags matching the prefix
            let tags;
            try {
              const response = await github.rest.git.listMatchingRefs({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${tagPrefix}`
              });
              tags = response.data;
            } catch (error) {
              console.log(`Error fetching tags: ${error.message}`);
              core.setOutput('workflow_passed', 'false');
              core.setOutput('error_message', `No tag found for ${kmom}. Push ${tagPrefix}.0 with passing tests first.`);
              return;
            }
            
            if (tags.length === 0) {
              console.log('No tags found');
              core.setOutput('workflow_passed', 'false');
              core.setOutput('error_message', `No tag found for ${kmom}. Push ${tagPrefix}.0 with passing tests first.`);
              return;
            }
            
            // Sort tags by semantic version (descending)
            const sortedTags = tags
              .map(tag => {
                const tagName = tag.ref.replace('refs/tags/', '');
                const versionMatch = tagName.match(/^v(\d+)\.(\d+)(?:\.(\d+))?$/);
                if (!versionMatch) return null;
                return {
                  name: tagName,
                  sha: tag.object.sha,
                  major: parseInt(versionMatch[1], 10),
                  minor: parseInt(versionMatch[2], 10),
                  patch: versionMatch[3] ? parseInt(versionMatch[3], 10) : 0
                };
              })
              .filter(t => t !== null)
              .sort((a, b) => {
                if (a.major !== b.major) return b.major - a.major;
                if (a.minor !== b.minor) return b.minor - a.minor;
                return b.patch - a.patch;
              });
            
            if (sortedTags.length === 0) {
              console.log('No valid semantic version tags found');
              core.setOutput('workflow_passed', 'false');
              core.setOutput('error_message', `No valid tag found for ${kmom}. Push ${tagPrefix}.0 with passing tests first.`);
              return;
            }
            
            const latestTag = sortedTags[0];
            console.log(`Latest tag: ${latestTag.name} (SHA: ${latestTag.sha})`);
            
            // Dereference the tag to get the commit SHA
            const tagObject = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `tags/${latestTag.name}`
            });
            
            let commitSha = tagObject.data.object.sha;
            
            // If it's an annotated tag, we need to get the commit it points to
            if (tagObject.data.object.type === 'tag') {
              const annotatedTag = await github.rest.git.getTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_sha: commitSha
              });
              commitSha = annotatedTag.data.object.sha;
            }
            
            console.log(`Commit SHA for tag: ${commitSha}`);
            
            // Check workflow runs for this commit SHA
            const workflowRuns = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              event: 'push',
              head_sha: commitSha,
              status: 'completed',
              per_page: 100
            });
            
            console.log(`Found ${workflowRuns.data.workflow_runs.length} completed workflow runs for tag ${latestTag.name}`);
            
            if (workflowRuns.data.workflow_runs.length === 0) {
              core.setOutput('workflow_passed', 'false');
              core.setOutput('error_message', `Tag ${latestTag.name} has no completed workflow runs. Wait for workflows to complete or push a new tag.`);
              return;
            }
            
            // Check if at least one workflow succeeded
            const successfulRun = workflowRuns.data.workflow_runs.find(run => run.conclusion === 'success');
            
            if (successfulRun) {
              console.log(`✅ Tag ${latestTag.name} has successful workflow run: ${successfulRun.html_url}`);
              core.setOutput('workflow_passed', 'true');
              core.setOutput('error_message', '');
            } else {
              console.log(`❌ Tag ${latestTag.name} has no successful workflow runs`);
              const failedRun = workflowRuns.data.workflow_runs[0];
              core.setOutput('workflow_passed', 'false');
              core.setOutput('error_message', `Tag ${latestTag.name} workflow failed. Fix the errors and push a new tag with passing tests.`);
            }

  run-tester:
    needs: validate-tag
    if: needs.validate-tag.outputs.workflow_passed == 'true'
    uses: bth-algo/utils/.github/workflows/tester.yml@main
    with:
      kmom_paths: ${{ inputs.kmom_paths }}
    secrets: inherit

  submit-canvas:
    needs: [validate-tag, run-tester]
    if: needs.validate-tag.outputs.workflow_passed == 'true' && needs.run-tester.outputs.tests_passed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Add "Tests passed" label
        uses: actions-ecosystem/action-add-labels@v1
        with:
          github_token: ${{ secrets.read_org_token }}
          labels: "Tests passed"

      - id: created_body
        run: |
          cat << EOF >> $GITHUB_OUTPUT
          myoutput<<EOM
          Pull Request action: ${{ github.event.action }}<br>
          <br>
          <h2>${{github.event.pull_request.title}}<br></h2>
          ${{github.event.pull_request.body}}<br>
          <br>
          PR URL: <a class='inline_disabled' href='${{ github.event.pull_request.html_url }}' target='_blank' rel='noopener noreferrer'>${{ github.event.pull_request.html_url }}</a>
          EOM
          EOF

      - uses: bth-python/utils/.github/actions/get-assignment-id@main
        id: resolve
        with:
          available_assignments: ${{ inputs.available_assignments }}

      - name: Update Canvas result from tests
        uses: bth-python/utils/.github/actions/update-canvas@main
        id: update_canvas
        with:
          subcommand: "submit_assignment"
          comment: "${{ steps.created_body.outputs.myoutput }}"
          canvas_api_token: ${{ secrets.CANVAS_API_TOKEN }}
          student_id: ${{ inputs.student_id }}
          course_id: ${{inputs.course_id}}
          assignment_id: ${{ steps.resolve.outputs.assignment }}
          read_org_token: "${{ secrets.READ_ORG_TOKEN }}"
      
      - name: Put comment in PR about submission
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.READ_ORG_TOKEN }}
          script: |
            const commentBody = `✅ Assignment submitted to Canvas for ${latestTag.name}. PR is ready for grading.`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });

  handle-canvas-failure:
    needs: [submit-canvas]
    if: always() && needs.submit-canvas.result == 'failure'
    runs-on: ubuntu-latest
    steps:
      - name: Comment on PR about Canvas submission failure
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.READ_ORG_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ❌ Canvas Submission Failed\n\nThe assignment could not be submitted to Canvas. This is likely a system issue.\n\n### What to do: Go through the instructions of setting up the repo and make sure you have done all steps correctly. If you are sure everything is correct, then:\
                \n1. Contact your instructor or course administrator\n2. Provide them with this PR link for help\n\nThis PR has been automatically closed.\n\n### You will need to open a new PR when you have resolved the issue.`
            });

      - name: Close PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.READ_ORG_TOKEN }}
          script: |
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              state: 'closed'
            });

  close-pr:
    needs: [validate-tag, run-tester]
    if: always() && (needs.validate-tag.outputs.workflow_passed != 'true' || needs.run-tester.outputs.tests_passed != 'true')
    runs-on: ubuntu-latest
    steps:
      - name: Determine error message
        id: determine-message
        run: |
          if [[ "${{ needs.validate-tag.outputs.workflow_passed }}" != "true" ]]; then
            echo "error_message=${{ needs.validate-tag.outputs.error_message }}" >> $GITHUB_OUTPUT
          else
            echo "error_message=Tests failed for the latest tag. Fix the errors and push a new tag with passing tests." >> $GITHUB_OUTPUT
          fi

      - name: Comment on PR with error message
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.READ_ORG_TOKEN }}
          script: |
            const errorMessage = `${{ steps.determine-message.outputs.error_message }}`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ❌ Submission Requirements Not Met\n\n${errorMessage}\n\n### What to do:\n1. Fix any errors in your code\n2. Ensure all tests pass locally\n3. Push a new tag with working code\n4. Open a new pull request when ready\n\nThis PR has been automatically closed.`
            });

      - name: Close PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.READ_ORG_TOKEN }}
          script: |
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              state: 'closed'
            });
